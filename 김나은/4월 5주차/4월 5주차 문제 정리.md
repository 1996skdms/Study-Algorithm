#  4월 5주차 풀이
## BOJ G4 1344 축구
### **Idea**
- 적어도 한 팀이 골을 소수로 득점할 확률 = 1 - 두 팀 모두 소수가 아닌 수로 득점할 확률
- 축구 경기는 90분, 경기를 5분 간격으로 나눴으므로 0 ~ 18 중 소수가 아닌 수일 때의 경우만 계산

### 코드
```java
double A = sc.nextDouble() / 100;
double B = sc.nextDouble() / 100;
double dp[][][] = new double[19][19][19];

dp[0][0][0] = 1;
for (int interval = 0; interval < 18; interval++) {
	for (int a = 0; a <= interval; a++) {
		for (int b = 0; b <= interval; b++) {
			double cur = dp[interval][a][b];
			dp[interval + 1][a][b] += cur * (1 - A) * (1 - B);
			dp[interval + 1][a + 1][b] += cur * A * (1 - B);
			dp[interval + 1][a][b + 1] += cur * (1 - A) * B;
			dp[interval + 1][a + 1][b + 1] += cur * A * B;
		}
	}
}

double ans = 0;
int[] num = { 0, 1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18 }; // 0 ~ 18 중 소수가 아닌 수일 때의 경우
for (int i = 0; i < 12; i++) {
	for (int j = 0; j < 12; j++) {
		ans += dp[18][num[i]][num[j]];
	}
}
```

### 후기

처음에는 조합을 이용해서 계산식을 세웠는데, 이를 코드로 구현하는 과정에서 dp로 변경하였다!
코드 자체는 심플하지만 구현하는데 머리가 안 돌아가서 시간이 꽤 걸렸다.
알고리즘은 안 풀면 실력이 뚝뚝 떨어지는 것 같다ㅠㅠ 5월부터 다시 1일 1알고를 실천해야겠다!!! 

---

## BOJ G4 2616 소형기관차
### **Idea**
- dp 문제
- 누적 합을 이용하여 객차에 타고 있던 손님의 수 누적
- 소형 기관차는 3대로 고정이며, 기관차가 끌고 가던 객차의 수와 소형 기관차가 최대로 끌 수 있는 객차의 수만 변하므로 => dp는 2차원 배열

### 코드
```java
for (int i = 1; i <= train; i++) {
	passenger[i] = Integer.parseInt(st.nextToken());
	sum[i] = sum[i-1] + passenger[i];
}

int coach = Integer.parseInt(br.readLine());
int[][] dp = new int[4][train+1];
for (int i = 1; i <= 3; i++) {
	// 각 소형 기관차는 번호가 연속적으로 이어진 객차를 끌게하므로 j는 i번 소형기관차 * 소형 기관차가 최대로 끌 수 있는 객차의 수부터 시작  
	for (int j = i*coach; j <= train; j++) {
		// 현재 객차를 넣지 못하는 상황 , 이전 소형 기관차가 최대로 태울 수 있는 손님의 수 + 그 이후부터 j객차까지 타고 있던 손님의 수
		dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j-coach] + (sum[j]-sum[j-coach]));
	}
}
```

### 후기

객차의 수가 50,000 이하라는 조건을 보고 dp문제라는 것까지는 생각을 했는데 구현 방법이 떠오르지 않아 알고리즘 분류를 참고하였다. 0/1 Knapsack을 응용하면 될 것 같아서 이를 바탕으로 구현해보았다!

----

## BOJ G2 17825 주사위 윷놀이

