#  5월 2주차 풀이
## BOJ G4 1593 문자 해독
### **Idea**
- 시간 제한 2초 => 1 ≤ g ≤ 3000 , S ≤ 3,000,000 이므로 슬라이딩 윈도우 사용
- 모든 문자열은 대소문자를 구분 => 배열 2개로 따로 관리

### 코드
```java
int length = 0, ans = 0;
for (int i = 0; i < s; i++) {
	char c = S.charAt(i);
	if ('a' <= c && c <= 'z') lowerCnt[c-'a']++;
	else upperCnt[c-'A']++;
	length++;
	if (length == g) {
		c = S.charAt(i - g + 1);
		if (Arrays.equals(lower, lowerCnt) && Arrays.equals(upper, upperCnt)) ans++;
		if ('a' <= c && c <= 'z') lowerCnt[c-'a']--;
		else upperCnt[c-'A']--;
		length--;
	}
}
```

### 후기

이런저런 풀이를 생각해보다가 시간 제한 때문에 결국은 슬라이딩 윈도우를 사용하였다
하지만 중복되는 코드가 많아서 예쁘지가 않다... 코드 최적화를 하고 싶은데 어떻게 해야할 지 잘 모르겟다ㅠ

---

## BOJ G5 1089 피자 굽기
### **Idea**
- 깊이에 따른 오븐의 지름은 오븐의 최상단부터 시작해서 작은 값으로 갱신  
- 최하단 가장 깊은 곳부터 시작해서 피자 반죽의 지름이 오븐의 지름보다 작거나 같으면 들어갈 수 있다

### 코드
```java
int[] oven = new int[D];
st = new StringTokenizer(br.readLine());
oven[0] = Integer.parseInt(st.nextToken());
for (int i = 1; i < D; i++) {
	oven[i] = Math.min(Integer.parseInt(st.nextToken()), oven[i-1]);
}
```

```java
int cnt = 0, ans = 0;
for (int depth = D-1; depth >= 0; depth--) {
	if (pizza[cnt] <= oven[depth]) {
		cnt++;
		ans = depth;
	}
	if (cnt == N) break;
}
```

### 후기

처음에는 2중 for문으로 구현했는데 시간초과가 나서 오븐의 지름을 갱신해주는 로직을 생각해내는데 시간이 오래걸린 것 같다
이후 마지막 피자 반죽의 위치를 찾는 것은 수월하게 해결할 수 있었다~

----

## BOJ G5 1089 스타트링크 타워
### **Idea**
- 0 ~ 9까지 3차원 배열에 저장
- 숫자에서 전구가 꺼져있는 자리에 번호 안내판의 전구가 켜져있지 않으면 숫자 후보 가능
- 자릿수마다 숫자 후보의 평균(num/cnt) * 자릿수(digit)로 계산

### 코드
```java
double ans = 0, digit = 1;
for (int i = N - 1; i >= 0; i--) {
	int num = 0, cnt = 0;
	for (int j = 0; j < 10; j++) {
		boolean flag = false;
		for (int k = 0; k < 5; k++) {
			for (int l = 0; l < 3; l++)
				if (numbers[j][k][l] == '.' && board[k][4*i+l] == '#') flag = true;
		}
		if (!flag) {
			cnt++;
			num += j;
		}
	}
	if (cnt == 0) ans = -1;
	else {
		ans += num * digit / cnt;
		digit *= 10;
	}
}
```

### 후기

예제는 다 통과했는데 제출하면 틀려서... 오류를 잡아야할 것 같습니다ㅠㅠ
